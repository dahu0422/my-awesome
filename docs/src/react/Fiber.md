# Fiber

## Fiber 的诞生：从同步阻塞到异步调度

在 React 15 及之前的版本中，React 使用的是 Stack Reconciler （栈调和器），采用**递归**方式处理虚拟 DOM 更新。这一机制存在几个关键瓶颈：

- 不可中断的同步更新：一旦开始渲染，必须一次性完成整个组件树的遍历和比对，无法中途暂停；
- 无优先级控制：所有更新任务平等处理，用户点击等高优先级操作无法插队。
- **长时间任务阻塞主线程**：深层次组件树或负责计算会导致 JavaScript 长时间占用主线成，造成页面卡顿甚至冻结。

随着应用复杂度上升，这些问题在动画、手势操作等场景下变得尤为明显。React 团队意识到必须重构底层架构 ———— Fiber 由此诞生。

## Fiber 的本质与作用

Fiber 是 React 16 引入的一种全新的数据结构和调度架构，核心作用有三点：

**本质上，Fiber 是一种链表结构的数据单元**。每个 Fiber 节点对应一个组件实例，记录类型、props、state、关联的 DOM 节点，以及与其他 Fiber 节点的关系（如 child、sibling、return 指针）。

```js
// 简化的 Fiber 节点结构示例
{
  type: 'div',             // 组件类型（函数/类/原生标签）
  key: null,               // React 元素 key
  stateNode: divDOM,       // 关联的真实 DOM 节点
  child: Fiber,            // 第一个子节点
  sibling: Fiber,          // 下一个兄弟节点
  return: Fiber,           // 父节点
  pendingProps: {className: 'active'}, // 待处理的 props
  memoizedState: {count: 1}, // 当前状态
  flags: Placement,        // 标记需要执行的副作用（如插入DOM）
}
```

- **架构层面，Fiber 取代了原有的递归栈调和器**，成为 React 16 及以上版本的默认协调引擎（Fiber Reconciler）。它让 React 能够将渲染任务拆分为更细粒度的单元，支持任务的中断、恢复和优先级调度。

- **调度层面，Fiber 让渲染变成可中断、可恢复的"工作单元"**。每个 Fiber 节点就是一个最小的工作单元，React 可以根据浏览器空闲时间分批处理这些单元，实现异步渲染和优先级插队。

## 核心原理：可中断的渲染、优先级调度、双缓冲机制

Fiber 的突破性在于它解决了同步渲染的根本缺陷，核心原理包含了三个关键设计：

### 可中断渲染

Fiber 将渲染过程拆分为一个个小任务（fiber 单元），每处理完一个 fiber 节点，React 都有机会暂停当前工作，把控制权交给浏览器（比如响应用户输入、动画等），等浏览器空闲再继续未完成的工作。

### 优先级调度

React 为任务划分 5 个优先级等级，调度器根据优先级动态调整执行顺序：

| **优先级**       | **场景**               | **处理策略**             |
| ---------------- | ---------------------- | ------------------------ |
| Immediate (最高) | 用户输入、动画         | 当前帧立即执行           |
| UserBlocking     | 交互反馈（如点击响应） | 快速响应，超时提升优先级 |
| Normal (默认)    | 数据更新、渲染         | 常规调度                 |
| Low              | 非关键数据拉取         | 可被高优先级打断         |
| Idle (最低)      | 分析日志、预加载       | 空闲时执行               |

### 双缓存机制

Fiber 采用双缓冲（Double Buffering）机制，当前屏幕显示的 fiber 树称为 **current tree**，正在构建的新 fiber 树成为 **workInProgress tree**。

完成更新后，workInProgress tree 会变成新的 current tree，实现高效切换。

## 实现机制：两段渲染与浏览器协作

### 阶段 1：Reconciliation 协调 ———— 可中断

遍历阶段主要任务是**构建新的 Fiber 树**，找出本次更新和上次渲染之间的差异（diff），并生成需要执行的副作用（effect list），比如插入、更新、删除等。

过程：

- 开始于根节点（Root Fiber），自顶向下遍历整棵 Fiber 树。
- 对每个 Fiber 节点，执行如下操作：
  1. **比较新旧 props、state**，判断是否需要更新。
  2. **生成新的子 Fiber 节点**，并建立父子、兄弟关系。
  3. **收集副作用**（如需要插入、删除、更新的节点）。
- 遍历方式：采用深度优先遍历（DFS），优先处理子节点，再处理兄弟节点。
- 可中断：遍历阶段是可中断的，React 可以在合适的时机暂停遍历，把控制权交还给浏览器（比如响应用户输入），等空闲时再继续。

### 阶段 2：Commit —————— 不可中断

提交阶段的主要任务是**根据副作用链表，执行实际的 DOM 操作**，并调用生命周期钩子（如 componentDidMount、useEffect 等）。

过程：

- 不可中断：提交阶段是同步且不可中断的，必须一次性完成，保证 UI 一致性。
- 分为三个子阶段：
  1. before mutation（变更前）主要执行 getSnapshotBeforeUpdate 等生命周期钩子。
  2. mutation（变更）遍历副作用链表，执行实际的 DOM 操作（插入、更新、删除）。
  3. layout（布局）执行 componentDidMount、componentDidUpdate、useLayoutEffect 等生命周期钩子。

### Fiber 与浏览器事件循环的关系

React Fiber 的可中断渲染能力，离不开浏览器事件循环（Event Loop）的支持。

**事件循环是 JS 执行的基础机制**，负责调度宏任务、微任务、渲染任务等。每一轮循环，浏览器会处理用户输入、定时器、网络等事件，并在合适时机执行页面渲染。

**Fiber 的"分片渲染"**，正是利用了事件循环的机制。React 会将渲染任务拆分为许多小单元（fiber 节点），每处理完一个小单元后，判断当前帧是否有空闲时间：

- 如果有空闲时间，继续处理下一个 Fiber 节点；
- 就暂停渲染，把控制权交还给浏览器，让浏览器优先处理用户输入、动画等高优先级任务。

这种"让出主线程"的能力，通常依赖于 `requestIdleCallback`、`MessageChannel` 等调度 API，这些 API 都是基于事件循环实现的。

等到浏览器下次空闲时，`requestIdleCallback`、`MessageChannel` 等调度 API 会再次被触发，React 会从上次中断的地方继续处理剩下的 fiber 节点，直到整棵 Fiber 树遍历完成。

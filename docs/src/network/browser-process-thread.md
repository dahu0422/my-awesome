# 浏览器进程、线程

## 进程、线程概念

进程 Process：

- 是**程序运行的基本单位**。
- 每个进程都有独立的内存空间和系统资源。
- 操作系统管理资源分配的基本单位。
- 多个进程之间的数据不能直接共享，需要通过进程间通信（IPC）。

线程 Thread

- 是**程序执行的最小单位**，是进程内的一个执行流。
- 一个进程可以包含多个线程，共享该进程的内存和资源。
- 多线程之间的数据可以直接共享，通信成本低。


## 浏览器中的进程与线程模型

现代浏览器是**多进程架构**，主要进程包括：

| 进程名称       | 作用                                                |
| ---------- | ------------------------------------------------- |
| **浏览器主进程** | 负责浏览器 UI、标签页管理、地址栏输入、前进后退、资源协调、子进程管理等。            |
| **渲染进程**   | 每个标签页（或 iframe）对应一个或多个渲染进程，负责将 HTML/CSS/JS 渲染为网页。 |
| **GPU 进程** | 专门用于 GPU 加速绘图（如 3D、CSS3 动画、Canvas 加速等）。           |
| **网络进程**   | 处理网络资源的加载，比如 HTTP 请求、缓存、Cookie 等。                 |
| **插件进程**   | （已逐渐废弃）为运行浏览器插件（如 Flash）而开设的独立进程。                 |


**渲染进程**是执行页面渲染的核心，内部又包含多个线程：

| 线程名称           | 作用                                                  |
| -------------- | --------------------------------------------------- |
| **主线程（UI 线程、JS引擎线程）** | 负责解析 HTML、CSS、执行 JavaScript、构建 DOM 树、布局、绘制等。是浏览器核心。 |
| **事件触发线程**     | 来自浏览器内核，用于处理定时器（`setTimeout`）、事件队列、用户输入等。           |
| **渲染线程（合成线程）** | 将主线程输出的内容合成图层，准备绘制，进行页面合成与更新。                       |
| **绘制线程（栅格线程）** | 把渲染线程合成好的图层转化为位图，提交到 GPU。                           |
| **GPU 线程**     | 实际负责图形绘制。与 GPU 进程配合完成加速。                            |

## 在浏览器地址栏输入 URL 都有哪些进程、线程参与工作？


1. 用户输入 URL（浏览器主进程）：浏览器主进程管该事件，准备启动加载流程；
2. 查找缓存（网络进程 + 本地磁盘访问线程）：查询本地缓存（DNS 缓存、HTTP 缓存）是否已有结果；
3. DNS 解析（网络进程）：网络进程向系统或自定义 DNS 服务器发送请求，解析出域名的 IP。同时也会通过 多路复用、连接池 管理 TCP 连接。
4. 建立 TCP 连接（网络进程）：与目标服务器通过 TCP 三次握手建立连接。如果是 HTTPS，还会进行 TLS 握手，建立加密通道。
5. 发送 HTTP 请求（网络进程）：构造并发送请求头、请求体。请求的内容可能是 HTML 页面、图片、脚本等。
6. 服务器响应并返回数据（网络进程）：网络进程接收服务器返回的响应数据。如果是首次访问，数据来自服务器；否则可能走缓存。
7. 提交文档给渲染进程（浏览器主进程 → 渲染进程）：网络进程收到 HTML 后，通知浏览器主进程。浏览器主进程根据同源策略/进程策略创建或复用一个渲染进程。
8. 渲染页面（渲染进程 + 多线程协作）：

  | 步骤      | 负责线程            | 说明             |
  | ------- | --------------- | -------------- |
  | 解析 HTML | 主线程（UI 线程）      | 构建 DOM 树       |
  | 解析 CSS  | 主线程             | 构建 CSSOM 树     |
  | 生成渲染树   | 主线程             | DOM + CSSOM 组合 |
  | 布局计算    | 主线程             | 确定位置大小         |
  | 分层 + 合成 | 合成线程            | 创建层次结构         |
  | 栅格化     | 栅格线程            | 转换为位图          |
  | 绘制到屏幕   | GPU 线程 + GPU 进程 | 显示图像到用户屏幕      |

  
##  浏览器中线程之间是如何通信的

浏览器中虽然有很多线程，但线程之间**不能直接操作彼此的数据**，必须通过某种“安全桥梁”通信。

常见通信方式：

1. 任务队列：浏览器维护一个任务队列，不同线程将任务推入这个队列。主线程从队列中取任务并执行。
2. 回调机制：比如网络线程下载完成后，通过回调函数将任务投递给主线程，主线程会在合适的时间执行这个回调（加入任务队列）
3. Web Worker 线程间通信：Web Worker 是浏览器中的多线程方案，主线程和 Worker 使用 `postMessage` 和 `onMessage` 通信。数据是通过**结构化拷贝**传输的，而不是共享内存。

## JavaScript 的事件循环（Event Loop）如何协调这些线程

JavaScript 是单线程语言，但浏览器借助多线程，实现了“看似异步”的能力。

核心参与者：

| 名称             | 作用                                 |
| -------------- | ---------------------------------- |
| **主线程**        | 负责执行 JS 代码，处理 DOM、事件、渲染等。          |
| **任务队列**       | 存放异步任务的回调，比如 setTimeout、Promise 等。 |
| **Web API 线程** | 浏览器提供的线程：计时器线程、网络线程、事件线程、渲染线程等。    |


JS 执行过程：

1. 主线程执行同步代码（如变量声明、函数调用、DOM 操作）
2. 遇到**异步任务**（如 `setTimeout`、`fetch`、`Promise`等），被**挂起交给对应的浏览器线程处理**（比如定时器线程、网络线程）
3. 处理完成后，浏览器线程会把**回调函数**送入**相应的任务队列（宏任务队列 or 微任务队列）**
4. 主线程空闲时，进入**事件循环（Event Loop）**，每次循环从**宏任务队列中取一个宏任务执行**。执行完宏任务后，**立即执行所有微任务队列中的任务**，直到清空。
5. 进入下一轮事件循环。

任务队列分为两种类型：

**宏任务：**`setTimeout`、`setInterval`、`setImmediate`、`MessageChannel`、`<script>` 脚本，每次 Event Loop 循环只执行一个宏任务。
**微任务：**`Promise.then`、`MutationObserver`、`queueMicrotask`，每个宏任务完成后，会清空所有微任务队列。

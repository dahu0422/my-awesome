# Electron 进程模型

Electron 应用基于 Chromium 和 Node.js，采用多进程架构。这种架构设计继承自 Chromium，为桌面应用提供了更好的稳定性、安全性和性能。

## 为什么是多进程架构？

Electron 的核心是 Chromium + Node.js，而 Chromium 本身就是一个多进程架构。

![Chrome 进程架构](https://www.electronjs.org/zh/assets/images/chrome-processes-0506d3984ec81aa39985a95e7a29fbb8.png)

采用多进程架构带来的好处：

- **稳定性**：一个网页崩溃只会影响该窗口，不会导致整个应用崩溃。每个渲染进程相互隔离，互不影响。
- **安全性**：由于应用需要访问本地文件系统，可能运行不受信任的 Web 内容（如内嵌浏览器），多进程隔离可以防范 XSS 攻击升级为系统攻击。
- **性能**：多进程可以充分利用多核 CPU，实现并行处理，提升应用响应速度。

## 主进程（Main Process）

一个 Electron 应用只有一个主进程，它是应用的入口点。主进程运行在 Node.js 环境中，可以完全访问 Node.js API（如 `require('fs')`）以及 Electron 提供的原生 API。

主进程做的事情：

- **创建和管理窗口**：通过 `BrowserWindow` 模块创建并控制各个窗口，每个窗口对应一个独立的渲染进程。
- **管理应用生命周期**：使用 `app` 模块处理应用的启动、就绪、退出等关键事件。
- **系统交互**：配置操作系统菜单、托盘图标、对话框、系统通知，访问文件系统，执行其他系统级操作。
- **进程间通信**：通过 `ipcMain` 模块处理来自渲染进程的消息和请求。

主进程就像应用的"大脑"，负责协调和管理所有窗口和系统资源。

## 渲染进程（Renderer Process）

渲染进程负责显示网页内容，每个 `BrowserWindow` 实例运行在独立的渲染进程中。

渲染进程运行在类似浏览器的环境中，基于 Chromium 的渲染引擎。默认情况下，渲染进程无法直接访问 Node.js API（出于安全考虑），需要通过预加载脚本或进程间通信（IPC）来访问系统能力。

渲染进程做的事情：

- **渲染 Web 内容**：加载并显示 HTML、CSS 和 JavaScript 构成的网页。
- **处理用户交互**：响应用户在窗口内的点击、输入等操作。
- **执行前端逻辑**：运行像 Vue、React 等前端框架代码。

每个窗口都是一个独立的渲染进程，进程之间相互隔离。如果某个渲染进程崩溃，不会影响主进程和其他渲染进程。

## 主进程与渲染进程的关系

```
主进程 (main.js)
  ├── 创建 BrowserWindow 1 → 渲染进程 1 (显示页面 A)
  ├── 创建 BrowserWindow 2 → 渲染进程 2 (显示页面 B)
  └── 管理所有窗口和进程
```

主进程通过创建 `BrowserWindow` 实例来创建渲染进程。渲染进程之间相互隔离，互不影响。进程间通过 IPC（进程间通信）进行数据交换。

## Preload 脚本

Preload 脚本（预加载脚本）是 Electron 中一个重要的概念，它在网页内容加载之前运行，在渲染进程中执行。

### 为什么需要 Preload 脚本？

默认情况下，渲染进程无法直接访问 Node.js API。如果直接在渲染进程中启用 `nodeIntegration`，虽然可以访问 Node.js API，但这会带来严重的安全风险：任何网页代码都可以直接访问系统资源。

Preload 脚本提供了一个安全的中间层，它可以访问 Node.js API 和 Electron API，运行在独立的上下文中，与网页内容隔离，通过 `contextBridge` 安全地向网页暴露有限的 API。
